0010   D748             .org _asm_exec_ram
0011   D748 CD 33 D8    	call reset_values
0012   D74B CD 7E 4A    	call _clrLCD
0013   D74E 3E 00       	ld a,0
0014   D750 32 0F C0    	ld (_curRow),a
0015   D753 3E 00       	ld a,0
0016   D755 32 10 C0    	ld (_curCol),a
0017   D758 FD CB 12 D6 	set indiconly,(iy+indicflags)
0018   D75C CD C4 D7    	call RedrawDisp
0019   D75F             	;ld de,$0001
0020   D75F             
0021   D75F             loop:
0022   D75F             
0023   D75F             	;push de
0024   D75F CD 5D DA    	call TryReceive
0025   D762             	;pop de
0026   D762             	
0027   D762             	;dec de
0028   D762             	;ld a,d
0029   D762             	;or e
0030   D762             	;cp 0
0031   D762             	;jp nz,kbd_check
0032   D762             	;ld de,$2FFF
0033   D762             	
0034   D762             	;call RedrawDisp
0035   D762             	
0036   D762             kbd_check:
0037   D762 3E BF       	ld a,%10111111
0038   D764 D3 01       	out (kbdPort),a
0039   D766 00          	nop
0040   D767 00          	nop
0041   D768 DB 01       	in a,(kbdPort)
0042   D76A CB 77       	bit 6,a
0043   D76C CA 21 D8    	jp z,Quit
0044   D76F             	
0045   D76F 3E FD       	ld a,%11111101
0046   D771 D3 01       	out (kbdPort),a
0047   D773 00          	nop
0048   D774 00          	nop
0049   D775 DB 01       	in a,(kbdPort)
0050   D777 4F          	ld c,a
0051   D778 21 10 DB    	ld hl,LastKeys
0052   D77B 23          	inc hl
0053   D77C C5          	push bc
0054   D77D 46          	ld b,(hl)
0055   D77E A8          	xor b
0056   D77F             	
0057   D77F CB 47       	bit 0,a				; Enter
0058   D781 F5          	push af
0059   D782 C4 BD D7    	call nz,EnterKey
0060   D785 F1          	pop af
0061   D786 C1          	pop bc
0062   D787 21 10 DB    	ld hl,LastKeys
0063   D78A 23          	inc hl
0064   D78B 71          	ld (hl),c
0065   D78C             	
0066   D78C 3E FE       	ld a,%11111110
0067   D78E D3 01       	out (kbdPort),a
0068   D790 00          	nop
0069   D791 00          	nop
0070   D792 DB 01       	in a,(kbdPort)
0071   D794 4F          	ld c,a
0072   D795 21 10 DB    	ld hl,LastKeys
0073   D798 C5          	push bc
0074   D799 46          	ld b,(hl)
0075   D79A A8          	xor b
0076   D79B             	
0077   D79B CB 47       	bit 0,a				; Down
0078   D79D F5          	push af
0079   D79E C4 AF D7    	call nz,DownKey
0080   D7A1 F1          	pop af
0081   D7A2 CB 5F       	bit 3,a				; Up
0082   D7A4 C4 B6 D7    	call nz,UpKey
0083   D7A7 C1          	pop bc
0084   D7A8 21 10 DB    	ld hl,LastKeys
0085   D7AB 71          	ld (hl),c
0086   D7AC C3 5F D7    	jp loop
0087   D7AF             	
0088   D7AF             DownKey:
0089   D7AF CB 41       	bit 0,c
0090   D7B1 C8          	ret z
0091   D7B2 CD 77 D9    	call MenuTryDown
0092   D7B5 C9          	ret
0093   D7B6             
0094   D7B6             UpKey:
0095   D7B6 CB 59       	bit 3,c
0096   D7B8 C8          	ret z
0097   D7B9 CD 95 D9    	call MenuTryUp
0098   D7BC C9          	ret
0099   D7BD             
0100   D7BD             EnterKey:
0101   D7BD CB 41       	bit 0,c
0102   D7BF C8          	ret z
0103   D7C0 CD AE D9    	call MenuSelectOption
0104   D7C3 C9          	ret
0105   D7C4             
0106   D7C4             RedrawDisp:
0107   D7C4 CD CB D7    	call DispEnergy
0108   D7C7 CD BC D8    	call DispMenu
0109   D7CA C9          	ret
0110   D7CB             
0111   D7CB             ; Destroys h, l
0112   D7CB             DispEnergy:
0113   D7CB             	; Clear top line of display
0114   D7CB 3E 00       	ld a,0
0115   D7CD 32 0F C0    	ld (_curRow),a
0116   D7D0 32 10 C0    	ld (_curCol),a
0117   D7D3 3E 20       	ld a,' '
0118   D7D5 06 14       	ld b,20
0119   D7D7             _ClearLoop:
0120   D7D7 CD 2B 4A    	call _putc
0121   D7DA 10 FB       	djnz _ClearLoop
0122   D7DC             	
0123   D7DC             	; Calculate beginning column to center text
0124   D7DC 21 02 DB    	ld hl,Energy+2
0125   D7DF CD AC D8    	call AsciiLength
0126   D7E2 50          	ld d,b
0127   D7E3 21 08 DB    	ld hl,Energy_Label
0128   D7E6 CD AC D8    	call AsciiLength
0129   D7E9 7A          	ld a,d
0130   D7EA 80          	add a,b
0131   D7EB CB 3F       	srl a
0132   D7ED 47          	ld b,a
0133   D7EE 3E 0A       	ld a,10
0134   D7F0 90          	sub b
0135   D7F1 32 10 C0    	ld (_curCol),a
0136   D7F4             	
0137   D7F4             	; Print energy label + value
0138   D7F4 21 08 DB    	ld hl,Energy_Label
0139   D7F7 CD 37 4A    	call _puts
0140   D7FA 21 02 DB    	ld hl,Energy+2
0141   D7FD CD 37 4A    	call _puts
0142   D800 C9          	ret
0143   D801             
0144   D801             ; When TryReceive says there's data waiting, it should call this.
0145   D801             ; This will process the data in the Accumulator from TryReceive
0146   D801             ; and possibly call ReceiveByte to fetch all the data.
0147   D801             ProcessData:
0148   D801 57          	ld d,a
0149   D802 1E 00       	ld e,0
0150   D804 D5          	push de
0151   D805 CD 6E DA    	call ReceiveByte
0152   D808 D1          	pop de
0153   D809 5F          	ld e,a
0154   D80A D0          	ret nc
0155   D80B             	
0156   D80B 21 00 DB    	ld hl,Energy
0157   D80E CD 14 D8    	call UpdateInt16
0158   D811 CD CB D7    	call DispEnergy
0159   D814             	
0160   D814             ; HL = Address of value to update
0161   D814             ; DE = New value for address
0162   D814             ; Destroys a, b, c, d, e, h, l
0163   D814             UpdateInt16:
0164   D814 72          	ld (hl),d
0165   D815 23          	inc hl
0166   D816 73          	ld (hl),e
0167   D817 23          	inc hl
0168   D818 E5          	push hl
0169   D819 CD 55 D8    	call Num2ASCII
0170   D81C E1          	pop hl
0171   D81D CD 87 D8    	call AsciiShrink
0172   D820 C9          	ret
0173   D821             	
0174   D821             ; Quits the program.
0175   D821             Quit:
0176   D821 FD CB 12 96 	res indiconly,(iy+indicflags)
0177   D825 CD 7E 4A    	call _clrLCD
0178   D828 3E 00       	ld a,0
0179   D82A 32 0F C0    	ld (_curRow),a
0180   D82D 3E 00       	ld a,0
0181   D82F 32 10 C0    	ld (_curCol),a
0182   D832 C9          	ret
0183   D833             
0184   D833             reset_values:
0185   D833 21 00 DB    	ld hl,Energy
0186   D836 11 00 00    	ld de,0
0187   D839 CD 14 D8    	call UpdateInt16
0188   D83C             	
0189   D83C 3E 00       	ld a,0
0190   D83E 21 12 DB    	ld hl,Division_Mod10
0191   D841 77          	ld (hl),a
0192   D842 23          	inc hl
0193   D843 77          	ld (hl),a
0194   D844 23          	inc hl
0195   D845             	
0196   D845 21 14 DB    	ld hl,Division_Value
0197   D848 77          	ld (hl),a
0198   D849 23          	inc hl
0199   D84A 77          	ld (hl),a
0200   D84B 23          	inc hl
0201   D84C             	
0202   D84C 3E FF       	ld a,$FF
0203   D84E 32 10 DB    	ld (LastKeys),a
0204   D851 32 11 DB    	ld (LastKeys+1),a
0205   D854 C9          	ret
0206   D855             
0207   D855             #include "inc/ascii.asm"
0001+  D855             ; Convert 16-bit binary value to decimal, in ASCII format.
0002+  D855             ; HL = address to output 5-characters of ASCII + null to
0003+  D855             ; DE = value to convert to ASCII
0004+  D855             Num2ASCII:
0005+  D855 01 F0 D8    	ld	bc,-10000
0006+  D858 CD 6D D8    	call	_Num1
0007+  D85B 01 18 FC    	ld	bc,-1000
0008+  D85E CD 6D D8    	call	_Num1
0009+  D861 01 9C FF    	ld	bc,-100
0010+  D864 CD 6D D8    	call	_Num1
0011+  D867 0E F6       	ld	c,-10
0012+  D869 CD 6D D8    	call	_Num1
0013+  D86C 48          	ld	c,b
0014+  D86D             _Num1:
0015+  D86D 3E 2F       	ld	a,'0'-1
0016+  D86F             _Num2:
0017+  D86F 3C          	inc	a
0018+  D870 E5          	push hl
0019+  D871 62          	ld h,d
0020+  D872 6B          	ld l,e
0021+  D873 09          	add	hl,bc
0022+  D874 54          	ld d,h
0023+  D875 5D          	ld e,l
0024+  D876 E1          	pop hl
0025+  D877 38 F6       	jr	c,_Num2
0026+  D879 E5          	push hl
0027+  D87A 62          	ld h,d
0028+  D87B 6B          	ld l,e
0029+  D87C ED 42       	sbc	hl,bc
0030+  D87E 54          	ld d,h
0031+  D87F 5D          	ld e,l
0032+  D880 E1          	pop hl
0033+  D881             
0034+  D881 77          	ld	(hl),a
0035+  D882 23          	inc	hl
0036+  D883 3E 00       	ld a,0
0037+  D885 77          	ld (hl),a
0038+  D886 C9          	ret
0039+  D887             	
0040+  D887             ; Shrinks ASCII number by removing leading ASCII 0's ($30)
0041+  D887             ; Inputs:
0042+  D887             ; HL = Address to start of ASCII string
0043+  D887             ; Destroys D, E, H, L, A
0044+  D887             AsciiShrink:
0045+  D887 54          	ld d,h
0046+  D888 5D          	ld e,l
0047+  D889             _ZeroLoop:
0048+  D889 7E          	ld a,(hl)
0049+  D88A FE 00       	cp $00
0050+  D88C CA A4 D8    	jp z,_ZeroDone
0051+  D88F FE 30       	cp '0'
0052+  D891 C2 98 D8    	jp nz,_DoShrink
0053+  D894 23          	inc hl
0054+  D895 C3 89 D8    	jp _ZeroLoop
0055+  D898             _DoShrink:
0056+  D898 12          	ld (de),a
0057+  D899 13          	inc de
0058+  D89A 23          	inc hl
0059+  D89B 7E          	ld a,(hl)
0060+  D89C FE 00       	cp $00
0061+  D89E CA A8 D8    	jp z,_Done
0062+  D8A1 C3 98 D8    	jp _DoShrink
0063+  D8A4             _ZeroDone:
0064+  D8A4 3E 30       	ld a,'0'
0065+  D8A6 12          	ld (de),a
0066+  D8A7 13          	inc de
0067+  D8A8             _Done:
0068+  D8A8 3E 00       	ld a,0
0069+  D8AA 12          	ld (de),a
0070+  D8AB C9          	ret
0071+  D8AC             
0072+  D8AC             ; Calculates the length of an ASCII string, not including the null-terminator.	
0073+  D8AC             ; Inputs:
0074+  D8AC             ; HL = Address to start of ASCII string
0075+  D8AC             ; Outputs:
0076+  D8AC             ; B  = Length of ASCII string, not including the null-terminator
0077+  D8AC             ; Destroys:
0078+  D8AC             ; A
0079+  D8AC             AsciiLength:
0080+  D8AC 3E 00       	ld a,0
0081+  D8AE 06 00       	ld b,0
0082+  D8B0             _Loop:
0083+  D8B0 7E          	ld a,(hl)
0084+  D8B1 FE 00       	cp 0
0085+  D8B3 CA BB D8    	jp z,_LengthDone
0086+  D8B6 04          	inc b
0087+  D8B7 23          	inc hl
0088+  D8B8 C3 B0 D8    	jp _Loop
0089+  D8BB             _LengthDone:
0090+  D8BB C9          	ret
0208   D8BC             #include "inc/menu.asm"
0001+  D8BC             DispMenu:
0002+  D8BC 3E 00       	ld a,0									; Set current row to 0 (AKA top line) and column to 0
0003+  D8BE 32 0F C0    	ld (_curRow),a							; (AKA beginning of line)
0004+  D8C1 3E 00       	ld a,0									; ...
0005+  D8C3 32 10 C0    	ld (_curCol),a							; ...
0006+  D8C6             	
0007+  D8C6 CD CD D8    	call CalculateMenuAddr					; Calculate which menu to display by ID
0008+  D8C9 CD FC D8    	call DispMenuLine						; Display calculated menu
0009+  D8CC C9          	ret
0010+  D8CD             	
0011+  D8CD             ; Calculates the address of the current menu's lookup table.
0012+  D8CD             ; Output:
0013+  D8CD             ; HL = lookup table address
0014+  D8CD             ; Destroys:
0015+  D8CD             ; a, b, c
0016+  D8CD             CalculateMenuAddr:
0017+  D8CD 3A CE D9    	ld a,(MenuOption)
0018+  D8D0             	
0019+  D8D0 E6 F8       	and %11111000							; Get current menu id
0020+  D8D2 CB 3F       	srl a									; Shift right 3 times to compensate for the and,
0021+  D8D4 CB 3F       	srl a									; then left once to double it for the add later.
0022+  D8D6             											; It evens out to 2 `srl`s
0023+  D8D6 21 CF D9    	ld hl,MenuOptionsTable
0024+  D8D9             _MenuLookupLoop:
0025+  D8D9 FE 00       	cp 0
0026+  D8DB CA EB D8    	jp z,_MenuLookupFound
0027+  D8DE 47          	ld b,a
0028+  D8DF 7C          	ld a,h
0029+  D8E0 B5          	or l
0030+  D8E1 FE 00       	cp 0
0031+  D8E3 CA F1 D8    	jp z,_MenuLookupInvalid
0032+  D8E6 23          	inc hl
0033+  D8E7 3D          	dec a
0034+  D8E8 C3 D9 D8    	jp _MenuLookupLoop
0035+  D8EB             _MenuLookupFound:
0036+  D8EB             	; Load address from lookup table into BC
0037+  D8EB 4E          	ld c,(hl)
0038+  D8EC 23          	inc hl
0039+  D8ED 46          	ld b,(hl)
0040+  D8EE             	; Load address in BC into HL
0041+  D8EE 60          	ld h,b
0042+  D8EF 69          	ld l,c
0043+  D8F0             	; HL contains the address of the current menu.
0044+  D8F0 C9          	ret
0045+  D8F1             _MenuLookupInvalid:
0046+  D8F1 3A CE D9    	ld a,(MenuOption)
0047+  D8F4 E6 07       	and %00000111
0048+  D8F6 32 CE D9    	ld (MenuOption),a
0049+  D8F9 C3 EB D8    	jp _MenuLookupFound
0050+  D8FC             
0051+  D8FC             ; Displays an option for the menu.
0052+  D8FC             ; Input:
0053+  D8FC             ; HL = Address to menu options
0054+  D8FC             ; Destroys:
0055+  D8FC             ; A, B, C, D, E
0056+  D8FC             DispMenuLine:
0057+  D8FC E5          	push hl								; If the line number is bad, we need to be able to recover HL
0058+  D8FD 3A CE D9    	ld a,(MenuOption)					; Load A with byte at MenuOption
0059+  D900 06 07       	ld b,%00000111						; Only keep bottom 3 bits (currently selected option #)
0060+  D902 A0          	and b								; to use as a counter before inverting colors
0061+  D903 3C          	inc a								; Increment A since `dec` comes before `cp`
0062+  D904 0E 00       	ld c,0								; Set to 1 when selected line is drawn. Used to make sure 
0063+  D906             										; a valid line number is selected.
0064+  D906             _DispLineLoop:
0065+  D906 47          	ld b,a								; Save A for later
0066+  D907 3A 0F C0    	ld a,(_curRow)						; Get current row (AKA line), increment it
0067+  D90A 3C          	inc a								; (AKA move to next line), and put new value
0068+  D90B 32 0F C0    	ld (_curRow),a						; back
0069+  D90E 3E 00       	ld a,0								; Set current column to 0 (AKA beginning of line)
0070+  D910 32 10 C0    	ld (_curCol),a						; ...
0071+  D913 78          	ld a,b								; Retrieve saved A value
0072+  D914             	
0073+  D914 5E          	ld e,(hl)							; Load DE with the bytes at HL and HL+1
0074+  D915 23          	inc hl								; ...
0075+  D916 56          	ld d,(hl)							; ...
0076+  D917 23          	inc hl								; ...
0077+  D918 47          	ld b,a								; Copy A register to B
0078+  D919 7A          	ld a,d								; Copy D to A and or with E: A will be zero only if
0079+  D91A B3          	or e								; D and E are both zero
0080+  D91B FE 00       	cp 0								; Reached null?
0081+  D91D CA 36 D9    	jp z,_DispLineDone					; If so, we're done.
0082+  D920 78          	ld a,b								; Otherwise, copy B back to A and decrease counter
0083+  D921 3D          	dec a								; ...
0084+  D922 FE 00       	cp 0								; If A is 0, this line should be highlighted.
0085+  D924 CC 46 D9    	call z,_SwapColor					; ...
0086+  D927 C4 41 D9    	call nz,_ResetColor					; Otherwise, reset color to normal.
0087+  D92A E5          	push hl								; _puts requires using HL, so push it to the stack,
0088+  D92B 62          	ld h,d								; load it with DE, and then call _puts. There is no
0089+  D92C 6B          	ld l,e								; `ld hl,de`, so split it into 2 commands.
0090+  D92D 23          	inc hl								; The option label starts with a 2-byte pointer to
0091+  D92E 23          	inc hl								; a subroutine, inc twice to get to the string.
0092+  D92F CD 37 4A    	call _puts							; Finally, display the line
0093+  D932 E1          	pop hl								; Pop HL from stack so it can be used again	
0094+  D933 C3 06 D9    	jp _DispLineLoop					; Continue the loop
0095+  D936             _DispLineDone:
0096+  D936 79          	ld a,c								; Checks C flag: if 0, no line was highlighted, so selected
0097+  D937 FE 00       	cp 0								; line number is bad and needs to be reset.
0098+  D939 CC 4D D9    	call z,_BadLine						; ...
0099+  D93C CD 41 D9    	call _ResetColor					; Ensure colors are set back in case last line was selected
0100+  D93F E1          	pop hl								; Pop HL so that we return to the right spot. Also means we don't
0101+  D940             										; destroy it, nice side benefit.
0102+  D940 C9          	ret									; Done
0103+  D941             _ResetColor:
0104+  D941 FD CB 05 9E 	res textInverse,(iy+textFlags)
0105+  D945 C9          	ret
0106+  D946             _SwapColor:
0107+  D946 0E 01       	ld c,1
0108+  D948 FD CB 05 DE 	set textInverse,(iy+textFlags)
0109+  D94C C9          	ret
0110+  D94D             _BadLine:
0111+  D94D 3E 00       	ld a,0								; Set current row to 0 (AKA top line) and column to 0
0112+  D94F 32 0F C0    	ld (_curRow),a						; (AKA beginning of line) as it would normally be on
0113+  D952 3E 00       	ld a,0								; entry to this subroutine.
0114+  D954 32 10 C0    	ld (_curCol),a						; ...
0115+  D957             	
0116+  D957 3A CE D9    	ld a,(MenuOption)					; Uh-oh! Line number was bad! Gotta reset it to 0!
0117+  D95A 06 F8       	ld b,%11111000						; Keep current menu number, but set option number
0118+  D95C A0          	and b								; to 0.
0119+  D95D 32 CE D9    	ld (MenuOption),a					; Save new value
0120+  D960             	
0121+  D960 D1          	pop de								; We need to pop HL, but the location for ret is on top.
0122+  D961 E1          	pop hl								; HL was pushed at the begining of the subroutine, so pop it,
0123+  D962 E5          	push hl								; but make sure to copy it back since it's popped again later.
0124+  D963 D5          	push de								; Make sure we put back the ret location!
0125+  D964 0E 01       	ld c,1								; Set the C flag to 1 so that if something goes terribly wrong
0126+  D966 3C          	inc a								; we don't create a fork bomb. Then increment A as detailed above
0127+  D967 C3 06 D9    	jp _DispLineLoop					; and try again.
0128+  D96A C9          	ret
0129+  D96B             
0130+  D96B             ; Calculates the length of a menu (AKA number of options)
0131+  D96B             ; Input:
0132+  D96B             ; HL = Menu Address
0133+  D96B             ; Output:
0134+  D96B             ; B = Length of menu
0135+  D96B             ; Destroys:
0136+  D96B             ; A, H, L
0137+  D96B             CalculateMenuLength:
0138+  D96B 06 FF       	ld b,255				; First command is an inc, 255 will make it overflow to 0
0139+  D96D             _MenuLengthLoop:
0140+  D96D 04          	inc b
0141+  D96E 7E          	ld a,(hl)
0142+  D96F FE 00       	cp 0
0143+  D971 C8          	ret z
0144+  D972 23          	inc hl
0145+  D973 23          	inc hl
0146+  D974 C3 6D D9    	jp _MenuLengthLoop
0147+  D977             
0148+  D977             ; Trys to move the menu cursor down, but does boundry checking to prevent invalid cursor IDs
0149+  D977             ; Destroys:
0150+  D977             ; A, B, C
0151+  D977             MenuTryDown:
0152+  D977 CD CD D8    	call CalculateMenuAddr			; Finds the starting address of the current menu, puts it in HL
0153+  D97A CD 6B D9    	call CalculateMenuLength		; Uses the address to find the length or max ID, puts it in B
0154+  D97D 3A CE D9    	ld a,(MenuOption)				; Gets the current cursor position, ignoring the rest
0155+  D980 0E 07       	ld c,%00000111					; ...
0156+  D982 A1          	and c							; ...
0157+  D983             	;ld c,a							; Swap A and B to make the comparison easier. Without this,
0158+  D983             	;ld a,b							; we would have to check the result of the carry and zero
0159+  D983             	;ld b,c							; flags. With it, we only need to check the carry.
0160+  D983 3C          	inc a							; Moves the cursor down and checks if it is still valid
0161+  D984 B8          	cp b							; ...
0162+  D985 D0          	ret nc							; If carry set, (current option+1) > length, so don't save
0163+  D986 47          	ld b,a
0164+  D987 3A CE D9    	ld a,(MenuOption)				; Otherwise, add menu ID back, save changes to MenuOption,
0165+  D98A 0E F8       	ld c,%11111000					; call DispMenu to redraw the menu, and ret.
0166+  D98C A1          	and c							; ...
0167+  D98D B0          	or b							; ...
0168+  D98E 32 CE D9    	ld (MenuOption),a				; ...
0169+  D991 CD BC D8    	call DispMenu					; ...
0170+  D994 C9          	ret								; ...
0171+  D995             	
0172+  D995             ; Trys to move the menu cursor up, but does boundry checking to prevent underflows
0173+  D995             ; Destroys:
0174+  D995             ; A, B, C
0175+  D995             MenuTryUp:
0176+  D995 3A CE D9    	ld a,(MenuOption)
0177+  D998 06 07       	ld b,%00000111
0178+  D99A A0          	and b
0179+  D99B FE 00       	cp 0
0180+  D99D C8          	ret z
0181+  D99E 3D          	dec a
0182+  D99F 4F          	ld c,a
0183+  D9A0 3A CE D9    	ld a,(MenuOption)
0184+  D9A3 06 F8       	ld b,%11111000
0185+  D9A5 A0          	and b
0186+  D9A6 B1          	or c
0187+  D9A7 32 CE D9    	ld (MenuOption),a
0188+  D9AA CD BC D8    	call DispMenu
0189+  D9AD C9          	ret
0190+  D9AE             
0191+  D9AE             MenuSelectOption:
0192+  D9AE CD CD D8    	call CalculateMenuAddr
0193+  D9B1 3A CE D9    	ld a,(MenuOption)
0194+  D9B4 06 07       	ld b,%00000111
0195+  D9B6 A0          	and b
0196+  D9B7             _MenuSelectLoop:
0197+  D9B7 FE 00       	cp 0
0198+  D9B9 CA C2 D9    	jp z,_MenuSelectItem
0199+  D9BC 3D          	dec a
0200+  D9BD 23          	inc hl
0201+  D9BE 23          	inc hl
0202+  D9BF C3 B7 D9    	jp _MenuSelectLoop
0203+  D9C2             _MenuSelectItem:
0204+  D9C2 5E          	ld e,(hl)
0205+  D9C3 23          	inc hl
0206+  D9C4 56          	ld d,(hl)
0207+  D9C5 62          	ld h,d
0208+  D9C6 6B          	ld l,e
0209+  D9C7 5E          	ld e,(hl)
0210+  D9C8 23          	inc hl
0211+  D9C9 56          	ld d,(hl)
0212+  D9CA 62          	ld h,d
0213+  D9CB 6B          	ld l,e
0214+  D9CC E9          	jp (hl)
0215+  D9CD C9          	ret
0216+  D9CE             
0217+  D9CE             #include "inc/menu_values.asm"
0001++ D9CE             MenuOption:
0002++ D9CE 00          	.db 00h									; Bottom 3 bits = currently selected option number (0=top)
0003++ D9CF             											; Top 5 bits = current menu number
0004++ D9CF             MenuOptionsTable:
0005++ D9CF D5 D9 DD D9 	.dw MenuA, MenuB, 0						; Lists all of the menus in order of their ID's
0005++ D9D3 00 00 
0006++ D9D5             	
0007++ D9D5             MenuA:
0008++ D9D5 E5 D9 F5 D9 	.dw MenuOptionA, MenuOptionB, MenuOptionNext, 0			; Lists all options in the menu, followed by null to indicate the end.
0008++ D9D9 1B DA 00 00 
0009++ D9DD             MenuB:
0010++ D9DD 05 DA 10 DA 	.dw MenuOptionC, MenuOptionD, MenuOptionPrev, 0			; Lists all options in the menu, followed by null to indicate the end.
0010++ D9E1 22 DA 00 00 
0011++ D9E5             
0012++ D9E5             ;-------------------------------------------------------------------------------------------------------------------------------;
0013++ D9E5             ;																																;
0014++ D9E5             ;							Place menu options below here. They should be ASCII and null-terminated.							;
0015++ D9E5             ;																																;
0016++ D9E5             ;-------------------------------------------------------------------------------------------------------------------------------;
0017++ D9E5             
0018++ D9E5             MenuOptionA:
0019++ D9E5 2D DA       	.dw OptionAExec
0020++ D9E7 4F 70 74 69 	.db "Option A (++)",0
0020++ D9EB 6F 6E 20 41 
0020++ D9EF 20 28 2B 2B 
0020++ D9F3 29 00 
0021++ D9F5             MenuOptionB:
0022++ D9F5 3C DA       	.dw OptionBExec
0023++ D9F7 4F 70 74 69 	.db "Option B (--)",0
0023++ D9FB 6F 6E 20 42 
0023++ D9FF 20 28 2D 2D 
0023++ DA03 29 00 
0024++ DA05             MenuOptionC:
0025++ DA05 2D DA       	.dw OptionAExec
0026++ DA07 4F 70 74 69 	.db "Option C",0
0026++ DA0B 6F 6E 20 43 
0026++ DA0F 00 
0027++ DA10             MenuOptionD:
0028++ DA10 3C DA       	.dw OptionBExec
0029++ DA12 4F 70 74 69 	.db "Option D",0
0029++ DA16 6F 6E 20 44 
0029++ DA1A 00 
0030++ DA1B             MenuOptionNext:
0031++ DA1B 4B DA       	.dw OptionNextExec
0032++ DA1D 4E 65 78 74 	.db "Next",0
0032++ DA21 00 
0033++ DA22             MenuOptionPrev:
0034++ DA22 54 DA       	.dw OptionPrevExec
0035++ DA24 50 72 65 76 	.db "Previous",0
0035++ DA28 69 6F 75 73 
0035++ DA2C 00 
0218+  DA2D             #include "inc/menu_callbacks.asm"
0001++ DA2D             OptionAExec:
0002++ DA2D 21 00 DB    	ld hl,Energy
0003++ DA30 56          	ld d,(hl)
0004++ DA31 23          	inc hl
0005++ DA32 5E          	ld e,(hl)
0006++ DA33 2B          	dec hl
0007++ DA34 13          	inc de
0008++ DA35 CD 14 D8    	call UpdateInt16
0009++ DA38 CD CB D7    	call DispEnergy
0010++ DA3B C9          	ret
0011++ DA3C             	
0012++ DA3C             OptionBExec:
0013++ DA3C 21 00 DB    	ld hl,Energy
0014++ DA3F 56          	ld d,(hl)
0015++ DA40 23          	inc hl
0016++ DA41 5E          	ld e,(hl)
0017++ DA42 2B          	dec hl
0018++ DA43 1B          	dec de
0019++ DA44 CD 14 D8    	call UpdateInt16
0020++ DA47 CD CB D7    	call DispEnergy
0021++ DA4A C9          	ret
0022++ DA4B             	
0023++ DA4B             OptionNextExec:
0024++ DA4B 3A CE D9    	ld a,(MenuOption)
0025++ DA4E C6 08       	add a,%00001000
0026++ DA50 32 CE D9    	ld (MenuOption),a
0027++ DA53 C9          	ret
0028++ DA54             	
0029++ DA54             OptionPrevExec:
0030++ DA54 3A CE D9    	ld a,(MenuOption)
0031++ DA57 D6 08       	sub %00001000
0032++ DA59 32 CE D9    	ld (MenuOption),a
0033++ DA5C C9          	ret
0209   DA5D             #include "inc/linkrout.asm"
0001+  DA5D             ;
0002+  DA5D             ; SOME VERY NICE LINK ROUTINES MADE BY PASCAL BOURON
0003+  DA5D             ;
0004+  DA5D             ; I've made some modifications so it fits ZTetris
0005+  DA5D             ;
0006+  DA5D             
0007+  DA5D             TryReceive:
0008+  DA5D DB 07       	in A,(7)
0009+  DA5F E6 03       	and 3
0010+  DA61             ;	and 1			;DEBUG
0011+  DA61 FE 03       	cp 3
0012+  DA63 C2 67 DA    	jp nz,recv
0013+  DA66 C9          	ret
0014+  DA67             recv:						
0015+  DA67 CD 6E DA    	call ReceiveByte
0016+  DA6A DC 01 D8    	call c,ProcessData ; Defined in main file
0017+  DA6D C9          	ret
0018+  DA6E             
0019+  DA6E             ReceiveByte:
0020+  DA6E 21 00 00    	ld hl,0
0021+  DA71 22 30 C1    	ld (lcounter),hl
0022+  DA74             
0023+  DA74 1E 01       	ld e,1
0024+  DA76 0E 00       	ld c,0					; byte receive
0025+  DA78 06 08       	ld b,8					; counter
0026+  DA7A 3E C0       	ld a,$C0
0027+  DA7C D3 07       	out (7),a
0028+  DA7E             rb_w_Start:
0029+  DA7E D5          	push de
0030+  DA7F 11 FF 07    	ld de,$07FF				; timeout
0031+  DA82             timeoutloop1:
0032+  DA82 1B          	dec de
0033+  DA83 7A          	ld a,d
0034+  DA84 B3          	or e
0035+  DA85 FE 00       	cp 0
0036+  DA87 CA C0 DA    	jp z,timeout
0037+  DA8A DB 07       	in a,(7)
0038+  DA8C E6 03       	and 3
0039+  DA8E             ;	and 1			;DEBUG
0040+  DA8E FE 03       	cp 3
0041+  DA90 20 02       	jr nz,rb_get_bit
0042+  DA92 18 EE       	jr timeoutloop1
0043+  DA94             rb_get_bit:
0044+  DA94 D1          	pop de
0045+  DA95 FE 02       	cp 2
0046+  DA97 28 09       	jr z,rb_receive_zero
0047+  DA99 79          	ld a,c
0048+  DA9A B3          	or e
0049+  DA9B 4F          	ld c,a
0050+  DA9C 3E D4       	ld a,$D4
0051+  DA9E D3 07       	out (7),a
0052+  DAA0 18 04       	jr rb_waitStop
0053+  DAA2             rb_receive_zero:
0054+  DAA2 3E E8       	ld a,$E8
0055+  DAA4 D3 07       	out (7),a
0056+  DAA6             rb_waitStop:
0057+  DAA6 16 FF       	ld d,$FF				; timeout
0058+  DAA8             timeoutloop2:
0059+  DAA8 15          	dec d
0060+  DAA9 7A          	ld a,d
0061+  DAAA FE 00       	cp 0
0062+  DAAC CA C0 DA    	jp z,timeout
0063+  DAAF DB 07       	in a,(7)
0064+  DAB1 E6 03       	and 3
0065+  DAB3 28 F3       	jr z,timeoutloop2
0066+  DAB5 3E C0       	ld a,$c0
0067+  DAB7 D3 07       	out (7),a
0068+  DAB9 CB 13       	rl e
0069+  DABB 10 C1       	djnz rb_w_Start
0070+  DABD 79          	ld a,c
0071+  DABE 37          	scf
0072+  DABF C9          	ret
0073+  DAC0             timeout:
0074+  DAC0 3E FF       	ld a,$ff
0075+  DAC2 3F          	ccf
0076+  DAC3 C9          	ret
0077+  DAC4             
0078+  DAC4             SendByte:
0079+  DAC4 21 00 00    	ld hl,0
0080+  DAC7 22 30 C1    	ld (lcounter),hl
0081+  DACA 06 08       	ld b,8
0082+  DACC 32 38 C1    	ld (sbyte),a
0083+  DACF 4F          	ld c,a			;byte to send
0084+  DAD0 3E C0       	ld a,$C0
0085+  DAD2 D3 07       	out (7),a
0086+  DAD4             w_setport3:
0087+  DAD4 DB 07       	in a,(7)
0088+  DAD6 E6 03       	and 3
0089+  DAD8 FE 03       	cp 3
0090+  DADA 28 02       	jr z,calc_bit
0091+  DADC 18 F6       	jr w_setport3
0092+  DADE             calc_bit:
0093+  DADE 79          	ld a,c
0094+  DADF E6 01       	and 1
0095+  DAE1 28 06       	jr z,send_one
0096+  DAE3             send_zero:
0097+  DAE3 3E E8       	ld a,$E8
0098+  DAE5 D3 07       	out (7),A
0099+  DAE7 18 04       	jr wait_setport
0100+  DAE9             send_one:
0101+  DAE9 3E D4       	ld a,$D4
0102+  DAEB D3 07       	out (7),A
0103+  DAED             wait_setport:
0104+  DAED DB 07       	in a,(7)
0105+  DAEF E6 03       	and 3
0106+  DAF1 20 FA       	jr nz,wait_setport
0107+  DAF3 3E C0       	ld a,$C0
0108+  DAF5 D3 07       	out (7),A
0109+  DAF7 CB 39       	srl c
0110+  DAF9 10 D9       	djnz w_setport3
0111+  DAFB AF          	xor a
0112+  DAFC 32 38 C1    	ld (sbyte),a
0113+  DAFF C9          	ret
0210   DB00             
0211   DB00             Energy:
0212   DB00 00 00       	.db 00h, 00h		; Allocate 2 bytes (16 bits) for energy counter. Stored as an uint16 in (high byte, low byte) format.
0213   DB02 30 30 30 30 	.db "00000",0		; Allocate 5 bytes (plus null) in ASCII format for _puts. This will be calculated whenever the value
0213   DB06 30 00 
0214   DB08             						; is updated to save time when it's needed for _puts.
0215   DB08             Energy_Label:
0216   DB08 45 6E 65 72 	.db "Energy:",0
0216   DB0C 67 79 3A 00 
0217   DB10             LastKeys:
0218   DB10 FF FF       	.db $FF, $FF		; All binary 1's (aka $FF) = no keys pressed. All 0's ($00) would mean all keys pressed.
0219   DB12             
0220   DB12             Division_Mod10:
0221   DB12 00 00       	.db 00h, 00h
0222   DB14             Division_Value:
0223   DB14 00 00       	.db 00h, 00h
0224   DB16             
0225   DB16             .END
tasm: Number of errors = 0
